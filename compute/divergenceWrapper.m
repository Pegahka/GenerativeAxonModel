function ret = divergenceWrapper(param,settings,div)

    % function: divergenceWrapper

    % input:

    % params: array of parameters. Contains numerical values generated by
    % the genetic algorithm.
    % settings: general settings structure initialized in initparams.m
    % div: structure containing the specific divergence measure (KL, KL reverse, JS)

    % output:

    % ret: the divergence between real data and the data generated using
    % the parameters from the params array with the generator settings set
    % in the settings structure.

    % parameter values are set in structure, in a format accepted by
    % generateFloret function.
    for i = 1:length(settings.params)
        gp.(settings.params{i,1}) = param(i);
    end

    % the floret generator and the divergence function also neeed this
    % paramaters from the general settings structure.
    gp.version = settings.generator_version;
    gp.gen_distr = settings.gen_distr;
    gp.res_distr = settings.res_distr;

    gp.no_florets = settings.no_florets;
    gp.divergence_fn = div;
    gp.real_data = settings.real_data;

    % fitness value
    [data,ret] = divergenceresult(gp); %It is in <main>/compute/divergenceresult.m
                                       %It generates multiple florets with the parameters supplied by GA ('param' array)
                                       %Then compares these generated florets
                                       %with real data (which comes from
                                       %init.mat->settings->gp).
                                       % ret is output of this function. It is tried to be minimized by GA.
                                       % Eventual 'ret' (calculated below) is weighted sum of two divergence values. 
                                       % One is the 'ret' here. Other is about asymetries (can be seen below).
                                       % So the 'ret' here could have been
                                       % named differently.
    if size(data) > 0
        if isfield(settings,'asymmetry')
            if (isfield(settings,'weightedasymmetry') && settings.weightedasymmetry)
                ret = settings.alpha * ret + (1-settings.alpha) ...
                * gp.divergence_fn(settings.asymmetry,asymmetries(data,true));
            else
                ret = settings.alpha * ret + (1-settings.alpha) ...
                * gp.divergence_fn(settings.asymmetry,asymmetries(data));
            end
        end
    end


    if isinf(ret) || isnan(ret)
       ret = 1/eps;
    end

end